name: Build MSI (WiX)

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          pip install pyinstaller pyyaml PySide6 requests

      - name: Add WiX to PATH
        shell: pwsh
        run: |
          $wix = Get-ChildItem 'C:\Program Files (x86)\WiX Toolset *\bin' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $wix) { Write-Error 'WiX bin folder not found.'; exit 1 }
          $wix.FullName | Out-File -FilePath $env:GITHUB_PATH -Append

      - name: Prepare sources
        run: |
          mkdir MiniFileBot

          # ---------- engine ----------
          cat > MiniFileBot/engine.py <<'EOF'
          # dummy placeholder, your real engine/core.py goes here
          class Engine:
              def __init__(self, cfg=None): pass
              def is_video(self, p): return str(p).lower().endswith((".mp4",".mkv",".avi"))
              def plan_batch(self, root): return []
              def plan_list(self, files): return []
              def execute(self, plans): pass
          EOF

          # ---------- GUI (recursive scan + instant planning) ----------
          cat > MiniFileBot/app_gui.py <<'EOF'
          from PySide6.QtWidgets import *
          from pathlib import Path
          import sys, yaml, traceback, os
          from engine import Engine

          CFG = Path("config.yaml")

          def load_cfg():
              return yaml.safe_load(CFG.read_text()) if CFG.exists() else {}

          def save_cfg(cfg):
              CFG.write_text(yaml.safe_dump(cfg, sort_keys=False))

          class DropList(QListWidget):
              def __init__(self, on_dropped, *a, **k):
                  super().__init__(*a, **k)
                  self.setAcceptDrops(True)
                  self.on_dropped = on_dropped
                  self.setStyleSheet("color:black;")
                  self.setUniformItemSizes(True)
                  self.setAlternatingRowColors(True)
              def dragEnterEvent(self, e):
                  if e.mimeData().hasUrls(): e.acceptProposedAction()
              def dragMoveEvent(self, e):
                  if e.mimeData().hasUrls(): e.acceptProposedAction()
              def dropEvent(self, e):
                  urls = [Path(u.toLocalFile()) for u in e.mimeData().urls() if u.isLocalFile()]
                  self.on_dropped(urls)

          class App(QWidget):
              def __init__(self):
                  super().__init__()
                  self.setWindowTitle("Mini FileBot — Rename")
                  self.resize(1200, 700)

                  self.cfg = load_cfg()
                  self.engine: Engine | None = None
                  self.roots: list[Path] = []
                  self.plans: list[tuple[Path, Path]] = []

                  self._ui()

              # ---------- UI ----------
              def _ui(self):
                  v = QVBoxLayout(self)

                  top = QHBoxLayout()
                  self.btn_add = QPushButton("Add Folder")
                  self.btn_add_files = QPushButton("Add Files")
                  self.db = QComboBox(); self.db.addItems(["Auto", "TMDb", "TVDB", "AniList"])
                  self.btn_fetch = QPushButton("Fetch Data")
                  self.btn_match = QPushButton("Match")
                  self.btn_rename = QPushButton("Rename")
                  self.btn_debug = QPushButton("Scan Debug")
                  self.btn_show = QPushButton("Show Sources")

                  for w in (self.btn_add, self.btn_add_files): top.addWidget(w)
                  top.addStretch(1)
                  top.addWidget(QLabel("Database:")); top.addWidget(self.db)
                  for w in (self.btn_fetch, self.btn_match, self.btn_rename, self.btn_debug, self.btn_show): top.addWidget(w)
                  v.addLayout(top)

                  cols = QHBoxLayout()
                  self.left = DropList(self._on_drop)
                  cols.addWidget(self.left, 4)
                  cols.addWidget(QLabel("→"))
                  self.right = QListWidget(); self.right.setStyleSheet("color:black;")
                  cols.addWidget(self.right, 5)
                  v.addLayout(cols)

                  self.progress = QProgressBar(); v.addWidget(self.progress)
                  self.log = QTextEdit(); self.log.setReadOnly(True); v.addWidget(self.log)

                  # wire
                  self.btn_add.clicked.connect(self._on_add_folder)
                  self.btn_add_files.clicked.connect(self._on_add_files)
                  self.btn_fetch.clicked.connect(self._on_fetch)
                  self.btn_match.clicked.connect(self._on_match)
                  self.btn_rename.clicked.connect(self._on_rename)
                  self.btn_debug.clicked.connect(self._on_debug)
                  self.btn_show.clicked.connect(self._fill_left_from_plans)

              # ---------- helpers ----------
              def _ensure_engine(self):
                  if not self.engine:
                      self.cfg.setdefault("providers", {})["preference"] = self.db.currentText()
                      save_cfg(self.cfg)
                      self.engine = Engine(self.cfg)

              def _engine_is_video(self, p: Path) -> bool:
                  if self.engine:
                      return self.engine.is_video(p)
                  return p.suffix.lower() in {".mkv",".mp4",".avi",".mov",".wmv",".m4v",".ts",".m2ts",".webm",".flv",".mk3d"}

              def _list_videos_recursive(self, root: Path) -> list[Path]:
                  files = []
                  try:
                      base = Path(root)
                      for dp, _, fns in os.walk(base):
                          for fn in fns:
                              fp = Path(dp) / fn
                              if self._engine_is_video(fp) and "sample" not in fp.name.lower():
                                  files.append(fp)
                  except Exception as e:
                      self.log.append(f"Scan error: {e}")
                  return files

              def _show_on_left(self, paths: list[Path | str]):
                  if not paths: return
                  self.left.addItems([str(p) for p in paths])
                  self.left.repaint()

              def _fill_left_from_plans(self):
                  self.left.clear()
                  if not self.plans:
                      self.log.append("No planned items to show.")
                      return
                  self._show_on_left([src for (src, _) in self.plans])
                  self.log.append(f"Listed {len(self.plans)} planned source file(s) in the left pane.")

              # ---------- actions ----------
              def _on_add_folder(self):
                  d = QFileDialog.getExistingDirectory(self, "Choose folder to scan")
                  if not d: return
                  root = Path(d)
                  self.roots.append(root)

                  vids = self._list_videos_recursive(root)
                  self._show_on_left(vids if vids else [root])
                  self.log.append(f"Added folder: {root}  (videos found: {len(vids)})")

                  self._ensure_engine()
                  new_plans = self.engine.plan_batch(root)
                  self.plans.extend(new_plans)
                  self.log.append(f"Planned {len(new_plans)} rename operations.")

              def _on_add_files(self):
                  files, _ = QFileDialog.getOpenFileNames(self, "Choose video files", "", "All files (*.*)")
                  if not files: return
                  self._show_on_left(files)
                  self._ensure_engine()
                  new_plans = self.engine.plan_list([Path(f) for f in files])
                  self.plans.extend(new_plans)
                  self.log.append(f"Added {len(files)} files, planned: {len(new_plans)}")

              def _on_drop(self, paths: list[Path]):
                  folders = [p for p in paths if p.is_dir()]
                  files = [p for p in paths if p.is_file()]

                  if folders:
                      for f in folders:
                          self.roots.append(f)
                          vids = self._list_videos_recursive(f)
                          self._show_on_left(vids if vids else [f])
                          self.log.append(f"Dropped folder: {f}  (videos found: {len(vids)})")
                          self._ensure_engine()
                          new_plans = self.engine.plan_batch(f)
                          self.plans.extend(new_plans)
                          self.log.append(f"Planned {len(new_plans)} rename operations for {f}.")

                  if files:
                      self._show_on_left(files)
                      self._ensure_engine()
                      new_plans = self.engine.plan_list(files)
                      self.plans.extend(new_plans)
                      self.log.append(f"Dropped files: {len(files)}, planned: {len(new_plans)}")

              def _on_fetch(self):
                  if not self.roots:
                      QMessageBox.information(self, "No folders", "Add a folder first.")
                      return
                  self._ensure_engine()
                  self.plans = []
                  tot = len(self.roots)
                  for i, r in enumerate(self.roots, 1):
                      self.plans += self.engine.plan_batch(r)
                      self.progress.setValue(int(i / tot * 100))
                  self.log.append(f"Fetched plans: {len(self.plans)}")

              def _on_match(self):
                  if not self.plans:
                      QMessageBox.information(self, "Nothing to match", "Fetch Data first.")
                      return
                  self.right.clear()
                  self.right.addItems([str(d) for _, d in self.plans])
                  self.right.repaint()
                  self.log.append("Matched — preview on the right.")

              def _on_rename(self):
                  if not self.plans:
                      QMessageBox.information(self, "Nothing to rename", "Match first.")
                      return
                  self._ensure_engine()
                  if QMessageBox.question(self, "Confirm", "Apply rename/move now?") != QMessageBox.Yes:
                      return
                  try:
                      self.engine.execute(self.plans)
                      self.log.append("Rename complete.")
                  except Exception:
                      self.log.append(traceback.format_exc())
                      QMessageBox.critical(self, "Rename Error", "See log.")

              def _on_debug(self):
                  if not self.roots:
                      QMessageBox.information(self, "No folders", "Add a folder first.")
                      return
                  total_seen = 0
                  for r in self.roots:
                      vids = self._list_videos_recursive(r)
                      total_seen += len(vids)
                      self.log.append(f"[debug] {r} -> videos found: {len(vids)}")
                  self.log.append(f"[debug] total videos across roots: {total_seen}")

          if __name__ == "__main__":
              app = QApplication(sys.argv)
              w = App(); w.show()
              sys.exit(app.exec())
          EOF

      - name: Build EXE
        run: pyinstaller --onefile --noconsole MiniFileBot/app_gui.py -n MiniFileBot

      - name: Build MSI with WiX
        run: |
          candle.exe installer.wxs -o installer.wixobj
          light.exe installer.wixobj -o MiniFileBot.msi

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v3
        with:
          name: MiniFileBot-MSI
          path: MiniFileBot.msi










