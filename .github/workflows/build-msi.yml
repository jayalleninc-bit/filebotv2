name: Build MiniFileBot MSI (robust scan + drag&drop)

on:
  push:
    branches: [ "main", "master" ]
  workflow_dispatch: {}

jobs:
  build:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Bootstrap project files (bash)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p MiniFileBot/engine/providers installer dist

          cat > MiniFileBot/requirements.txt <<'EOF'
          PySide6
          requests
          PyYAML
          guessit
          tqdm
          python-dateutil
          EOF

          # Very permissive defaults; you can set video_exts: ["*"] to accept all files.
          cat > MiniFileBot/config.yaml <<'EOF'
          paths:
            movie_dir: ./Movies
            tv_dir: ./TV
          providers:
            preference: "Auto"
            tmdb: { api_key: "", language: "en-US" }
            tvdb: { api_key: "", pin: "" }
            anilist: { enabled: true }
          behavior:
            action: move
            dry_run: true
            skip_samples: true
            max_depth: 100
          video_exts: [".mkv", ".mp4", ".avi", ".mov", ".wmv", ".m4v", ".ts", ".m2ts", ".webm", ".flv", ".mk3d"]
          patterns:
            movie: "{title} ({year})/{title} ({year})"
            episode: "{series}/Season {season:02}/{series} - S{season:02}E{episode:02} - {title}"
            anime_absolute: "{series}/{series} - {absolute:03}"
          EOF

          cat > MiniFileBot/engine/utils.py <<'EOF'
          from pathlib import Path
          import os, shutil
          def ensure_dir(p: Path): p.parent.mkdir(parents=True, exist_ok=True)
          def apply_action(src: Path, dst: Path, action="move", dry_run=True):
              ensure_dir(dst)
              if dry_run: return
              if action=="move": shutil.move(str(src), str(dst))
              elif action=="copy": shutil.copy2(src, dst)
              elif action=="hardlink": os.link(src, dst)
              elif action=="symlink":
                  if dst.exists(): dst.unlink()
                  dst.symlink_to(src)
              else: raise ValueError(action)
          EOF

          cat > MiniFileBot/engine/parsers.py <<'EOF'
          import re
          from guessit import guessit
          ABS=re.compile(r"(?<!\d)(\d{3,4})(?!\d)")
          def parse_filename(name:str)->dict:
              info=guessit(name)
              m=ABS.search(name)
              if m and info.get("type")!="movie" and "episode" not in info:
                  info["type"]="episode"; info["absolute"]=int(m.group(1)); info.setdefault("anime",True)
              return info
          EOF

          cat > MiniFileBot/engine/renamers.py <<'EOF'
          from dataclasses import dataclass
          from pathlib import Path
          @dataclass
          class Ctx: series=None; season=None; episode=None; absolute=None; title=None; year=None
          def rend(pat:str, c:Ctx, ext:str)->Path:
              s=lambda x:(x or "").replace("/","-").strip()
              d={"series":s(c.series),"season":c.season or 0,"episode":c.episode or 0,"absolute":c.absolute or 0,"title":s(c.title),"year":c.year or 0}
              return Path(pat.format(**d)+ext)
          EOF

          cat > MiniFileBot/engine/providers/tmdb.py <<'EOF'
          import requests
          class TMDb:
            def __init__(self,api_key:str,language="en-US"):
              self.b="https://api.themoviedb.org/3"; self.k=api_key; self.l=language; self.s=requests.Session()
            def _get(self,p,**q): q.setdefault("api_key",self.k); q.setdefault("language",self.l); r=self.s.get(self.b+p,params=q,timeout=20); r.raise_for_status(); return r.json()
            def search_movie(self,q,year=None):
              d=self._get("/search/movie",query=q,include_adult=False,year=year) if year else self._get("/search/movie",query=q,include_adult=False); r=d.get("results") or []; return r[0] if r else None
            def search_tv(self,q,year=None):
              d=self._get("/search/tv",query=q,include_adult=False,first_air_date_year=year) if year else self._get("/search/tv",query=q,include_adult=False); r=d.get("results") or []; return r[0] if r else None
            def episode_title(self,tv,sea,ep):
              try: return self._get(f"/tv/{tv}/season/{sea}/episode/{ep}").get("name")
              except Exception: return None
          EOF

          cat > MiniFileBot/engine/providers/tvdb.py <<'EOF'
          import requests
          class TVDB:
            def __init__(self,api_key:str,pin:str|None=None):
              self.k=api_key; self.pin=pin; self.b="https://api4.thetvdb.com/v4"; self.s=requests.Session(); self.t=None
              if api_key: self._login()
            def _login(self):
              r=self.s.post(self.b+"/login",json={"apikey":self.k,**({"pin":self.pin} if self.pin else {})},timeout=20); r.raise_for_status(); self.t=r.json().get("data",{}).get("token"); self.s.headers.update({"Authorization":f"Bearer {self.t}"})
            def search_series(self,q):
              if not self.t: return None
              r=self.s.get(self.b+"/search",params={"q":q,"type":"series"},timeout=20); r.raise_for_status(); d=r.json().get("data") or []; return d[0] if d else None
            def episodes_with_absolute(self,series_id:int):
              if not self.t: return []
              r=self.s.get(f"{self.b}/series/{series_id}/episodes/default",timeout=20); r.raise_for_status(); d=r.json().get("data") or {}; return d.get("episodes") or []
            def build_absolute_map(self,series_id:int):
              m={}
              for e in self.episodes_with_absolute(series_id):
                a=e.get("absoluteNumber"); s=e.get("seasonNumber"); n=e.get("number")
                if a and s and n: m[int(a)]={"season":int(s),"episode":int(n)}
              return m
          EOF

          # ---------- Engine: wildcard exts, deep crawl, scan stats, plan specific files ----------
          cat > MiniFileBot/engine/core.py <<'EOF'
          import os
          from dataclasses import dataclass
          from pathlib import Path
          from typing import Iterable
          import yaml
          from .parsers import parse_filename
          from .providers.tmdb import TMDb
          from .providers.tvdb import TVDB
          from .providers.anilist import AniList
          from .renamers import Ctx, rend
          from .utils import apply_action

          @dataclass
          class Settings:
            movie_dir: Path; tv_dir: Path
            pattern_movie: str; pattern_episode: str; pattern_anime_abs: str
            action: str; dry_run: bool; skip_samples: bool; max_depth: int; preference: str
            exts: set[str]; wildcard: bool

          class Engine:
            def __init__(self,cfg:dict):
              paths=cfg.get("paths",{}); prov=cfg.get("providers",{}); beh=cfg.get("behavior",{}); patt=cfg.get("patterns",{})
              exts_raw = cfg.get("video_exts") or [".mkv",".mp4",".avi",".mov",".wmv",".m4v",".ts",".m2ts",".webm",".flv",".mk3d"]
              wildcard = "*" in exts_raw
              exts=set(e.lower() for e in exts_raw if e != "*")
              self.s=Settings(
                Path(paths.get("movie_dir","./Movies")), Path(paths.get("tv_dir","./TV")),
                patt.get("movie","{title} ({year})/{title} ({year})"),
                patt.get("episode","{series}/Season {season:02}/{series} - S{season:02}E{episode:02} - {title}"),
                patt.get("anime_absolute","{series}/{series} - {absolute:03}"),
                beh.get("action","move"), bool(beh.get("dry_run",True)),
                bool(beh.get("skip_samples",True)), int(beh.get("max_depth",5)),
                prov.get("preference","Auto"), exts, wildcard
              )
              tm=prov.get("tmdb",{}); tv=prov.get("tvdb",{}); an=prov.get("anilist",{})
              self.tmdb=TMDb(api_key=os.getenv("TMDB_API_KEY",tm.get("api_key","")),language=tm.get("language","en-US"))
              self.tvdb=None; k=os.getenv("TVDB_API_KEY",tv.get("api_key",""))
              if k: self.tvdb=TVDB(api_key=k,pin=os.getenv("TVDB_PIN",tv.get("pin")))
              self.anilist= AniList() if (an.get("enabled",True)) else None

            def is_video(self,p:Path)->bool:
              if self.s.wildcard:
                return True
              return p.suffix.lower() in self.s.exts

            def walk(self,root:Path):
              root = Path(root).resolve()
              base_parts = len(root.parts)
              scanned = 0
              for dp,_,fns in os.walk(root):
                depth = len(Path(dp).parts) - base_parts
                if depth > self.s.max_depth:
                  continue
                for fn in fns:
                  p=Path(dp)/fn
                  scanned += 1
                  if self.s.skip_samples and "sample" in p.name.lower():
                    continue
                  if self.is_video(p):
                    yield p
              print(f"[scan] {root} -> entries seen: {scanned}")

            def plan_for(self,p:Path):
              info=parse_filename(p.name); ext=p.suffix
              if info.get("type")=="movie":
                mv=self.tmdb_movie(info)
                if not mv: return None
                title,year=mv; rel=rend(self.s.pattern_movie,Ctx(title=title,year=year),ext)
                return p, self.s.movie_dir/rel
              if info.get("type")=="episode":
                si=self.tmdb_series(info); series=(si or {}).get("name") or info.get("series") or info.get("title") or "Unknown"
                season=info.get("season"); ep=info.get("episode"); absno=info.get("absolute")
                if absno and not (season and ep):
                  hit=self.tvdb_map(series,absno)
                  if hit: season,ep=hit["season"],hit["episode"]
                if absno and not (season and ep):
                  rel=rend(self.s.pattern_anime_abs,Ctx(series=series,absolute=absno),ext); return p, self.s.tv_dir/rel
                if not (season and ep):
                  rel=rend(self.s.pattern_anime_abs,Ctx(series=series,absolute=absno),ext); return p, self.s.tv_dir/rel
                rel=rend(self.s.pattern_episode,Ctx(series=series,season=int(season),episode=int(ep)),ext); return p, self.s.tv_dir/rel
              return None

            def tmdb_movie(self,info):
              t=info.get("title") or info.get("movie_title") or info.get("series"); y=info.get("year")
              if not t: return None
              r=self.tmdb.search_movie(t,y)
              if not r: return None
              name=r.get("title") or r.get("name") or t
              y=(r.get("release_date") or "0000")[:4]
              try: y=int(y)
              except Exception: y=info.get("year")
              return name,y

            def tmdb_series(self,info):
              t=info.get("series") or info.get("title")
              return self.tmdb.search_tv(t) if t else None

            def tvdb_map(self,series,absno):
              if not self.tvdb: return None
              s=self.tvdb.search_series(series)
              if not s: return None
              sid=s.get("tvdb_id") or s.get("id")
              if not sid: return None
              m=self.tvdb.build_absolute_map(sid)
              return m.get(int(absno))

            def plan_batch(self,root:Path):
              out=[]
              planned=0
              for f in self.walk(root):
                pl=self.plan_for(f)
                if pl: out.append(pl); planned+=1
              print(f"[plan] {root} -> planned: {planned}")
              return out

            def plan_list(self, paths:Iterable[Path]):
              out=[]
              for p in paths:
                if self.s.skip_samples and "sample" in p.name.lower(): continue
                if not self.is_video(p): continue
                pl=self.plan_for(Path(p))
                if pl: out.append(pl)
              print(f"[plan] list -> planned: {len(out)}")
              return out

            def execute(self,plans:list[tuple]):
              for src,dst in plans:
                print(f'{"[DRY-RUN] " if self.s.dry_run else ""}{src} -> {dst}')
                apply_action(src,dst,self.s.action,self.s.dry_run)
          EOF

          # GUI: autoscan, drag&drop (files or folders), Scan Debug button
          cat > MiniFileBot/app_gui.py <<'EOF'
          from PySide6.QtWidgets import *
          from PySide6.QtCore import Qt, QUrl
          from pathlib import Path
          import yaml, sys, traceback
          from engine.core import Engine
          CFG=Path("config.yaml")
          def load(): return yaml.safe_load(CFG.read_text()) if CFG.exists() else {}
          def save(cfg): CFG.write_text(yaml.safe_dump(cfg, sort_keys=False))
          class DropList(QListWidget):
            def __init__(self, on_dropped, *a, **k):
              super().__init__(*a, **k)
              self.setAcceptDrops(True)
              self.on_dropped = on_dropped
            def dragEnterEvent(self, e):
              if e.mimeData().hasUrls(): e.acceptProposedAction()
            def dragMoveEvent(self, e):
              if e.mimeData().hasUrls(): e.acceptProposedAction()
            def dropEvent(self, e):
              urls = [Path(u.toLocalFile()) for u in e.mimeData().urls() if u.isLocalFile()]
              self.on_dropped(urls)
          class App(QWidget):
            def __init__(self):
              super().__init__(); self.setWindowTitle("Mini FileBot — Rename")
              self.cfg=load(); self.engine=None; self.roots=[]; self.plans=[]
              self.ui()
            def ui(self):
              v=QVBoxLayout(self)
              top=QHBoxLayout(); self.add=QPushButton("Add Folder"); self.db=QComboBox(); self.db.addItems(["Auto","TMDb","TVDB","AniList"])
              self.fetch=QPushButton("Fetch Data"); self.match=QPushButton("Match"); self.rename=QPushButton("Rename"); self.debug=QPushButton("Scan Debug")
              top.addWidget(self.add); top.addStretch(1); top.addWidget(QLabel("Database:")); top.addWidget(self.db)
              top.addWidget(self.fetch); top.addWidget(self.match); top.addWidget(self.rename); top.addWidget(self.debug); v.addLayout(top)
              cols=QHBoxLayout(); self.left=DropList(self.on_drop); self.left.setToolTip("Drop folders or video files here")
              mid=QVBoxLayout(); mid.addWidget(QLabel("→")); self.right=QListWidget(); self.right.setToolTip("New Names (preview)")
              cols.addWidget(self.left,4); midw=QWidget(); midw.setLayout(mid); cols.addWidget(midw,1); cols.addWidget(self.right,5); v.addLayout(cols)
              self.progress=QProgressBar(); v.addWidget(self.progress); self.log=QTextEdit(); self.log.setReadOnly(True); v.addWidget(self.log)
              self.add.clicked.connect(self.on_add); self.fetch.clicked.connect(self.on_fetch); self.match.clicked.connect(self.on_match); self.rename.clicked.connect(self.on_rename); self.debug.clicked.connect(self.on_debug)
            def ensure_engine(self):
              if not self.engine:
                self.cfg.setdefault("providers",{})["preference"]=self.db.currentText(); save(self.cfg); self.engine=Engine(self.cfg)
            def on_add(self):
              d=QFileDialog.getExistingDirectory(self,"Choose folder to scan")
              if d:
                p=Path(d); self.roots.append(p); self.log.append(f"Added: {p}")
                self.on_fetch()
            def on_drop(self, paths):
              # paths can be files or folders
              folders=[p for p in paths if p.is_dir()]
              files=[p for p in paths if p.is_file()]
              if folders: self.roots.extend(folders); self.log.append(f"Dropped folders: {', '.join(str(x) for x in folders)}"); self.on_fetch()
              if files:
                self.ensure_engine(); self.plans=self.engine.plan_list(files)
                self.left.clear(); [self.left.addItem(str(s)) for s,_ in self.plans]; self.log.append(f"Dropped files planned: {len(self.plans)}")
            def on_fetch(self):
              if not self.roots:
                QMessageBox.information(self,"No folders","Add a folder first."); return
              self.ensure_engine(); self.left.clear(); self.plans=[]; tot=len(self.roots)
              for i,r in enumerate(self.roots,1):
                self.plans+=self.engine.plan_batch(r); self.progress.setValue(int(i/tot*100))
              if not self.plans:
                QMessageBox.information(self,"No videos found","No matching files were found. Tip: set video_exts: ['*'] in config.yaml to accept all.")
                return
              for s,_ in self.plans: self.left.addItem(str(s))
              self.log.append(f"Fetched {len(self.plans)} file(s).")
            def on_match(self):
              if not self.plans: QMessageBox.information(self,"Nothing to match","Fetch first."); return
              self.right.clear(); [self.right.addItem(str(d)) for _,d in self.plans]; self.log.append("Matched — preview on the right.")
            def on_rename(self):
              if not self.plans: QMessageBox.information(self,"Nothing to rename","Match first."); return
              self.ensure_engine()
              if QMessageBox.question(self,"Confirm","Apply rename/move now?")!=QMessageBox.Yes: return
              try: self.engine.execute(self.plans); self.log.append("Rename complete.")
              except Exception: self.log.append(traceback.format_exc()); QMessageBox.critical(self,"Rename Error","See log.")
            def on_debug(self):
              if not self.roots: QMessageBox.information(self,"No folders","Add a folder first."); return
              self.ensure_engine()
              for r in self.roots:
                self.engine.plan_batch(r)  # prints [scan]/[plan] to log
              self.log.append("Debug scan completed. See lines above for counts.")
          if __name__=="__main__":
            app=QApplication(sys.argv); w=App(); w.resize(1200,700); w.show(); sys.exit(app.exec())
          EOF

          # WiX (same as your passing build)
          cat > installer/MiniFileBot.wxs <<'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
            <Product Id="*" Name="MiniFileBot" Language="1033" Version="1.0.0" Manufacturer="MiniFileBot" UpgradeCode="A1B2C3D4-E5F6-4A7B-8C9D-0123456789AB">
              <Package InstallerVersion="500" Compressed="yes" InstallScope="perMachine" />
              <MediaTemplate EmbedCab="yes" CompressionLevel="high" />
              <MajorUpgrade AllowDowngrades="no" DowngradeErrorMessage="A newer version of MiniFileBot is already installed." />
              <Feature Id="MainFeature" Title="MiniFileBot" Level="1">
                <ComponentGroupRef Id="AppFiles" />
                <ComponentRef Id="ApplicationShortcut" />
              </Feature>
              <Property Id="WIXUI_INSTALLDIR" Value="INSTALLFOLDER" />
              <UIRef Id="WixUI_InstallDir" />
              <UIRef Id="WixUI_ErrorProgressText" />
              <Directory Id="TARGETDIR" Name="SourceDir">
                <Directory Id="ProgramFilesFolder">
                  <Directory Id="INSTALLFOLDER" Name="MiniFileBot" />
                </Directory>
                <Directory Id="ProgramMenuFolder" />
              </Directory>
              <DirectoryRef Id="ProgramMenuFolder">
                <Component Id="ApplicationShortcut" Guid="{8F2C2F9D-2F3A-4B1E-A3B4-9D3E3C6F9B12}">
                  <Shortcut Id="ApplicationStartMenuShortcut" Name="MiniFileBot" Target="[INSTALLFOLDER]MiniFileBot.exe" WorkingDirectory="INSTALLFOLDER" />
                  <RemoveFolder Id="RemoveShortcutFolder" Directory="ProgramMenuFolder" On="uninstall" />
                  <RegistryValue Root="HKCU" Key="Software\MiniFileBot" Name="StartMenu" Type="string" Value="1" KeyPath="yes" />
                </Component>
              </DirectoryRef>
              <ComponentGroup Id="AppFiles" Directory="INSTALLFOLDER">
                <Component Id="ExeComponent" Guid="*">
                  <File Id="MiniFileBotExe" Source ="$(var.BuildOutput)\MiniFileBot.exe" KeyPath="yes" />
                </Component>
                <Component Id="ConfigComponent" Guid="*">
                  <File Id="ConfigYaml"  Source ="$(var.BuildOutput)\config.yaml" />
                </Component>
              </ComponentGroup>
            </Product>
          </Wix>
          EOF

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install -r MiniFileBot/requirements.txt pyinstaller

      - name: Build EXE (PyInstaller)
        shell: cmd
        working-directory: MiniFileBot
        run: |
          pyinstaller --noconfirm --clean --windowed --onefile app_gui.py ^
            --name MiniFileBot ^
            --collect-all PySide6 ^
            --collect-all guessit ^
            --collect-all babelfish ^
            --collect-all rebulk
          if not exist dist\MiniFileBot.exe exit /b 1
          copy config.yaml dist\config.yaml

      - name: Install WiX Toolset
        run: choco install wixtoolset --yes --no-progress

      - name: Add WiX to PATH
        shell: pwsh
        run: |
          $wix = Get-ChildItem "C:\Program Files (x86)\WiX Toolset *\bin" -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $wix) { Write-Error "WiX bin folder not found."; exit 1 }
          "$($wix.FullName)" | Out-File -FilePath $env:GITHUB_PATH -Append

      - name: Build MSI (WiX)
        shell: cmd
        working-directory: installer
        run: |
          if not exist ..\dist mkdir ..\dist
          set BUILDOUT=%CD%\..\MiniFileBot\dist
          candle.exe -dBuildOutput="%BUILDOUT%" MiniFileBot.wxs -o MiniFileBot.wixobj
          if errorlevel 1 exit /b 1
          light.exe MiniFileBot.wixobj -ext WixUIExtension -o ..\dist\MiniFileBot-Installer.msi
          if errorlevel 1 exit /b 1

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MiniFileBot-MSI
          path: |
            dist/**
            MiniFileBot/dist/**





