name: Build MSI (WiX)

on:
  workflow_dispatch: {}

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller pyyaml PySide6 requests

      - name: Add WiX to PATH
        shell: pwsh
        run: |
          $wix = Get-ChildItem 'C:\Program Files (x86)\WiX Toolset *\bin' -ErrorAction SilentlyContinue | Select-Object -First 1
          if (-not $wix) { Write-Error 'WiX bin folder not found.'; exit 1 }
          $wix.FullName | Out-File -FilePath $env:GITHUB_PATH -Append

      - name: Prepare sources
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p MiniFileBot

          # --- minimal engine placeholder (replace with your real engine if present) ---
          cat > MiniFileBot/engine.py <<'PY'
          class Engine:
              def __init__(self, cfg=None): pass
              def is_video(self, p): return str(p).lower().endswith((".mp4",".mkv",".avi",".mov",".webm",".m4v",".ts",".m2ts",".flv",".wmv",".mk3d"))
              def plan_batch(self, root): return []
              def plan_list(self, files): return []
              def execute(self, plans): pass
          PY

          # --- GUI with recursive scan + instant planning ---
          cat > MiniFileBot/app_gui.py <<'PY'
          from PySide6.QtWidgets import *
          from pathlib import Path
          import sys, yaml, traceback, os
          from engine import Engine

          CFG = Path("config.yaml")

          def load_cfg():
              return yaml.safe_load(CFG.read_text()) if CFG.exists() else {}

          def save_cfg(cfg):
              CFG.write_text(yaml.safe_dump(cfg, sort_keys=False))

          class DropList(QListWidget):
              def __init__(self, on_dropped, *a, **k):
                  super().__init__(*a, **k)
                  self.setAcceptDrops(True)
                  self.on_dropped = on_dropped
                  self.setStyleSheet("color:black;")
                  self.setUniformItemSizes(True)
                  self.setAlternatingRowColors(True)
              def dragEnterEvent(self, e):
                  if e.mimeData().hasUrls(): e.acceptProposedAction()
              def dragMoveEvent(self, e):
                  if e.mimeData().hasUrls(): e.acceptProposedAction()
              def dropEvent(self, e):
                  urls = [Path(u.toLocalFile()) for u in e.mimeData().urls() if u.isLocalFile()]
                  self.on_dropped(urls)

          class App(QWidget):
              def __init__(self):
                  super().__init__()
                  self.setWindowTitle("Mini FileBot — Rename")
                  self.resize(1200, 700)
                  self.cfg = load_cfg()
                  self.engine: Engine | None = None
                  self.roots: list[Path] = []
                  self.plans: list[tuple[Path, Path]] = []
                  self._ui()

              def _ui(self):
                  v = QVBoxLayout(self)
                  top = QHBoxLayout()
                  self.btn_add = QPushButton("Add Folder")
                  self.btn_add_files = QPushButton("Add Files")
                  self.db = QComboBox(); self.db.addItems(["Auto", "TMDb", "TVDB", "AniList"])
                  self.btn_fetch = QPushButton("Fetch Data")
                  self.btn_match = QPushButton("Match")
                  self.btn_rename = QPushButton("Rename")
                  self.btn_debug = QPushButton("Scan Debug")
                  self.btn_show = QPushButton("Show Sources")
                  for w in (self.btn_add, self.btn_add_files): top.addWidget(w)
                  top.addStretch(1)
                  top.addWidget(QLabel("Database:")); top.addWidget(self.db)
                  for w in (self.btn_fetch, self.btn_match, self.btn_rename, self.btn_debug, self.btn_show): top.addWidget(w)
                  v.addLayout(top)
                  cols = QHBoxLayout()
                  self.left = DropList(self._on_drop); cols.addWidget(self.left, 4); cols.addWidget(QLabel("→"))
                  self.right = QListWidget(); self.right.setStyleSheet("color:black;"); cols.addWidget(self.right, 5)
                  v.addLayout(cols)
                  self.progress = QProgressBar(); v.addWidget(self.progress)
                  self.log = QTextEdit(); self.log.setReadOnly(True); v.addWidget(self.log)
                  self.btn_add.clicked.connect(self._on_add_folder)
                  self.btn_add_files.clicked.connect(self._on_add_files)
                  self.btn_fetch.clicked.connect(self._on_fetch)
                  self.btn_match.clicked.connect(self._on_match)
                  self.btn_rename.clicked.connect(self._on_rename)
                  self.btn_debug.clicked.connect(self._on_debug)
                  self.btn_show.clicked.connect(self._fill_left_from_plans)

              def _ensure_engine(self):
                  if not self.engine:
                      self.cfg.setdefault("providers", {})["preference"] = self.db.currentText()
                      save_cfg(self.cfg)
                      self.engine = Engine(self.cfg)

              def _engine_is_video(self, p: Path) -> bool:
                  if self.engine: return self.engine.is_video(p)
                  return p.suffix.lower() in {".mkv",".mp4",".avi",".mov",".wmv",".m4v",".ts",".m2ts",".webm",".flv",".mk3d"}

              def _list_videos_recursive(self, root: Path) -> list[Path]:
                  files = []
                  try:
                      for dp, _, fns in os.walk(root):
                          for fn in fns:
                              fp = Path(dp) / fn
                              if self._engine_is_video(fp) and "sample" not in fp.name.lower():
                                  files.append(fp)
                  except Exception as e:
                      self.log.append(f"Scan error: {e}")
                  return files

              def _show_on_left(self, paths):
                  if not paths: return
                  self.left.addItems([str(p) for p in paths]); self.left.repaint()

              def _fill_left_from_plans(self):
                  self.left.clear()
                  if not self.plans:
                      self.log.append("No planned items to show."); return
                  self._show_on_left([src for (src, _) in self.plans])
                  self.log.append(f"Listed {len(self.plans)} planned source file(s).")

              def _on_add_folder(self):
                  d = QFileDialog.getExistingDirectory(self, "Choose folder to scan")
                  if not d: return
                  root = Path(d); self.roots.append(root)
                  vids = self._list_videos_recursive(root)
                  self._show_on_left(vids if vids else [root])
                  self.log.append(f"Added folder: {root} (videos: {len(vids)})")
                  self._ensure_engine()
                  new_plans = self.engine.plan_batch(root)
                  self.plans.extend(new_plans)
                  self.log.append(f"Planned {len(new_plans)} operations.")

              def _on_add_files(self):
                  files, _ = QFileDialog.getOpenFileNames(self, "Choose video files", "", "All files (*.*)")
                  if not files: return
                  self._show_on_left(files)
                  self._ensure_engine()
                  new_plans = self.engine.plan_list([Path(f) for f in files])
                  self.plans.extend(new_plans)
                  self.log.append(f"Added {len(files)} files, planned: {len(new_plans)}")

              def _on_drop(self, paths):
                  folders = [p for p in paths if p.is_dir()]
                  files = [p for p in paths if p.is_file()]
                  for f in folders:
                      self.roots.append(f)
                      vids = self._list_videos_recursive(f)
                      self._show_on_left(vids if vids else [f])
                      self.log.append(f"Dropped folder: {f} (videos: {len(vids)})")
                      self._ensure_engine()
                      new_plans = self.engine.plan_batch(f)
                      self.plans.extend(new_plans)
                      self.log.append(f"Planned {len(new_plans)} for {f}.")
                  if files:
                      self._show_on_left(files)
                      self._ensure_engine()
                      new_plans = self.engine.plan_list(files)
                      self.plans.extend(new_plans)
                      self.log.append(f"Dropped files: {len(files)}, planned: {len(new_plans)}")

              def _on_fetch(self):
                  if not self.roots:
                      QMessageBox.information(self, "No folders", "Add a folder first."); return
                  self._ensure_engine()
                  self.plans = []; tot = len(self.roots)
                  for i, r in enumerate(self.roots, 1):
                      self.plans += self.engine.plan_batch(r)
                      self.progress.setValue(int(i / tot * 100))
                  self.log.append(f"Fetched plans: {len(self.plans)}")

              def _on_match(self):
                  if not self.plans:
                      QMessageBox.information(self, "Nothing to match", "Fetch Data first."); return
                  self.right.clear()
                  self.right.addItems([str(d) for _, d in self.plans])
                  self.right.repaint()
                  self.log.append("Matched — preview on the right.")

              def _on_rename(self):
                  if not self.plans:
                      QMessageBox.information(self, "Nothing to rename", "Match first."); return
                  self._ensure_engine()
                  if QMessageBox.question(self, "Confirm", "Apply rename/move now?") != QMessageBox.Yes: return
                  try:
                      self.engine.execute(self.plans)
                      self.log.append("Rename complete.")
                  except Exception:
                      self.log.append(traceback.format_exc())
                      QMessageBox.critical(self, "Rename Error", "See log.")

              def _on_debug(self):
                  if not self.roots:
                      QMessageBox.information(self, "No folders", "Add a folder first."); return
                  total = 0
                  for r in self.roots:
                      vids = self._list_videos_recursive(r)
                      total += len(vids)
                      self.log.append(f"[debug] {r} -> videos: {len(vids)}")
                  self.log.append(f"[debug] total videos: {total}")

          if __name__ == "__main__":
              app = QApplication(sys.argv)
              w = App(); w.show()
              sys.exit(app.exec())
          PY

          # simple config file placed next to EXE
          cat > MiniFileBot/config.yaml <<'YAML'
          video_exts: [".mkv", ".mp4", ".avi", ".mov", ".wmv", ".m4v", ".ts", ".m2ts", ".webm", ".flv", ".mk3d"]
          providers: { preference: "Auto" }
          YAML

      - name: Build EXE
        run: |
          pyinstaller --noconfirm --windowed --onefile MiniFileBot/app_gui.py -n MiniFileBot
          copy MiniFileBot\config.yaml dist\config.yaml

      # If you also build an MSI, keep your WiX steps here…

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: MiniFileBot-dist
          path: |
            dist/**












