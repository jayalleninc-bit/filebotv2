# TVRenamer (WPF, .NET 8)

A lightweight, FileBot‑style Windows app that lets you **drag & drop** TV episode files, automatically looks them up on **TheTVDB (v4)** or **TVMaze** (fallback), and renames them using your preferred pattern (Season/Episode or Absolute Order). Includes a **WiX MSI installer** and a **GitHub Actions** workflow to build the `.msi` on every push.

---

## Repo layout
```
TVRenamer/
├─ src/
│  ├─ TvRenamer.App/            # WPF UI (drag & drop)
│  ├─ TvRenamer.Core/           # parsing, matching, providers
│  └─ TvRenamer.Installer/      # WiX v3 MSI project
├─ .github/workflows/build-msi.yml
├─ README.md
└─ LICENSE
```

---

## src/TvRenamer.Core/TvRenamer.Core.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="System.Text.Json" Version="8.0.5" />
    <PackageReference Include="Polly" Version="8.4.4" />
  </ItemGroup>
</Project>
```

## src/TvRenamer.Core/Models.cs
```csharp
namespace TvRenamer.Core;

public record EpisodeInfo(
    int Season,
    int Episode,
    int Absolute,
    string Title,
    DateTime? AirDate
);

public record SeriesInfo(
    string Provider,  // "tvdb" or "tvmaze"
    string SeriesId,
    string Name
);
```

## src/TvRenamer.Core/IMetadataProvider.cs
```csharp
using System.Threading.Tasks;

namespace TvRenamer.Core;

public interface IMetadataProvider
{
    Task<SeriesInfo?> SearchSeriesAsync(string query, CancellationToken ct);
    Task<IReadOnlyList<EpisodeInfo>> GetAllEpisodesAsync(string seriesId, CancellationToken ct);
}
```

## src/TvRenamer.Core/Providers/TvdbProvider.cs
```csharp
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;

namespace TvRenamer.Core;

public sealed class TvdbProvider : IMetadataProvider
{
    private readonly HttpClient _http;
    private readonly string _apiKey;
    private readonly string? _pin; // optional for user-supported keys
    private string? _token;

    public TvdbProvider(HttpClient http, string apiKey, string? pin = null)
    { _http = http; _apiKey = apiKey; _pin = pin; }

    private async Task EnsureTokenAsync(CancellationToken ct)
    {
        if (!string.IsNullOrWhiteSpace(_token)) return;
        var payload = new Dictionary<string, string?> { ["apikey"] = _apiKey };
        if (!string.IsNullOrWhiteSpace(_pin)) payload["pin"] = _pin;
        using var res = await _http.PostAsync(
            "https://api4.thetvdb.com/v4/login",
            new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json"), ct);
        res.EnsureSuccessStatusCode();
        using var s = await res.Content.ReadAsStreamAsync(ct);
        var doc = await JsonDocument.ParseAsync(s, cancellationToken: ct);
        _token = doc.RootElement.GetProperty("data").GetProperty("token").GetString();
        _http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", _token);
    }

    public async Task<SeriesInfo?> SearchSeriesAsync(string query, CancellationToken ct)
    {
        await EnsureTokenAsync(ct);
        using var res = await _http.GetAsync($"https://api4.thetvdb.com/v4/search?query={Uri.EscapeDataString(query)}&type=series", ct);
        if (!res.IsSuccessStatusCode) return null;
        var json = await res.Content.ReadAsStringAsync(ct);
        using var doc = JsonDocument.Parse(json);
        var data = doc.RootElement.GetProperty("data");
        if (data.GetArrayLength() == 0) return null;
        var first = data[0];
        var id = first.GetProperty("tvdb_id").GetInt32().ToString();
        var name = first.GetProperty("name").GetString() ?? query;
        return new SeriesInfo("tvdb", id, name);
    }

    public async Task<IReadOnlyList<EpisodeInfo>> GetAllEpisodesAsync(string seriesId, CancellationToken ct)
    {
        await EnsureTokenAsync(ct);
        var episodes = new List<EpisodeInfo>();
        int page = 0; bool more = true;
        // v4 series episodes list is paged under /series/{id}/episodes/default?page=N
        while (more)
        {
            var url = $"https://api4.thetvdb.com/v4/series/{seriesId}/episodes/default?page={page}";
            using var res = await _http.GetAsync(url, ct);
            res.EnsureSuccessStatusCode();
            var json = await res.Content.ReadAsStringAsync(ct);
            using var doc = JsonDocument.Parse(json);
            var data = doc.RootElement.GetProperty("data");
            foreach (var e in data.EnumerateArray())
            {
                int season = e.GetProperty("seasonNumber").GetInt32();
                int ep = e.GetProperty("number").GetInt32();
                var title = e.TryGetProperty("name", out var n) ? n.GetString() ?? "" : "";
                int absolute = e.TryGetProperty("absoluteNumber", out var a) && a.ValueKind == JsonValueKind.Number ? a.GetInt32() : 0;
                DateTime? air = null;
                if (e.TryGetProperty("aired", out var aired) && aired.ValueKind == JsonValueKind.String && DateTime.TryParse(aired.GetString(), out var dt)) air = dt;
                episodes.Add(new EpisodeInfo(season, ep, absolute, title, air));
            }
            var links = doc.RootElement.TryGetProperty("links", out var l) ? l : default;
            if (links.ValueKind == JsonValueKind.Object && links.TryGetProperty("next", out var next) && next.ValueKind == JsonValueKind.Number)
            {
                page = next.GetInt32();
                more = next.GetInt32() != 0; // tvdb returns 0 when no next
            }
            else more = false;
        }
        // Ensure absolute order fallback if API didn't provide absoluteNumber
        int abs = 1;
        foreach (var grp in episodes.OrderBy(e => e.Season).ThenBy(e => e.Episode))
        {
            if (grp.Absolute == 0)
            {
                episodes[episodes.IndexOf(grp)] = grp with { Absolute = abs };
            }
            abs++;
        }
        return episodes;
    }
}
```

## src/TvRenamer.Core/Providers/TvMazeProvider.cs
```csharp
using System.Text.Json;

namespace TvRenamer.Core;

public sealed class TvMazeProvider : IMetadataProvider
{
    private readonly HttpClient _http;
    public TvMazeProvider(HttpClient http) => _http = http;

    public async Task<SeriesInfo?> SearchSeriesAsync(string query, CancellationToken ct)
    {
        // simple single search endpoint
        using var res = await _http.GetAsync($"https://api.tvmaze.com/singlesearch/shows?q={Uri.EscapeDataString(query)}", ct);
        if (!res.IsSuccessStatusCode) return null;
        using var s = await res.Content.ReadAsStreamAsync(ct);
        using var doc = await JsonDocument.ParseAsync(s, cancellationToken: ct);
        var id = doc.RootElement.GetProperty("id").GetInt32().ToString();
        var name = doc.RootElement.GetProperty("name").GetString() ?? query;
        return new SeriesInfo("tvmaze", id, name);
    }

    public async Task<IReadOnlyList<EpisodeInfo>> GetAllEpisodesAsync(string seriesId, CancellationToken ct)
    {
        using var res = await _http.GetAsync($"https://api.tvmaze.com/shows/{seriesId}/episodes", ct);
        res.EnsureSuccessStatusCode();
        var json = await res.Content.ReadAsStringAsync(ct);
        using var doc = JsonDocument.Parse(json);
        var list = new List<EpisodeInfo>();
        int absolute = 1;
        foreach (var e in doc.RootElement.EnumerateArray())
        {
            int season = e.GetProperty("season").GetInt32();
            int ep = e.GetProperty("number").GetInt32();
            var title = e.GetProperty("name").GetString() ?? "";
            DateTime? air = null;
            if (e.TryGetProperty("airdate", out var ad) && DateTime.TryParse(ad.GetString(), out var dt)) air = dt;
            list.Add(new EpisodeInfo(season, ep, absolute++, title, air));
        }
        return list;
    }
}
```

## src/TvRenamer.Core/FileParsing.cs
```csharp
using System.Text.RegularExpressions;

namespace TvRenamer.Core;

public static class FileParsing
{
    private static readonly Regex SeasonEpisode = new(
        @"(?ix) # flexible SxxEyy or 1x02
          (?:S(?<s>\d{1,2})[ ._-]*E(?<e>\d{1,3}))
          |(?<s>\d{1,2})x(?<e>\d{1,3})",
        RegexOptions.Compiled);

    private static readonly Regex Absolute = new(
        @"(?ix)(?:^|[^\d])(?<abs>\d{1,4})(?:[^\d]|$)", RegexOptions.Compiled);

    public static (int? season, int? episode, int? absolute) ExtractNumbers(string fileName)
    {
        var name = Path.GetFileNameWithoutExtension(fileName);
        var m = SeasonEpisode.Match(name);
        if (m.Success)
        {
            return (int.Parse(m.Groups["s"].Value), int.Parse(m.Groups["e"].Value), null);
        }
        var a = Absolute.Matches(name)
            .Select(mm => int.TryParse(mm.Groups["abs"].Value, out var n) ? n : (int?)null)
            .Where(n => n.HasValue)
            .Select(n => n!.Value)
            .ToList();
        if (a.Count > 0) return (null, null, a.Last());
        return (null, null, null);
    }
}
```

## src/TvRenamer.Core/Renamer.cs
```csharp
namespace TvRenamer.Core;

public static class Renamer
{
    public static string BuildName(string series, EpisodeInfo ep, string pattern)
    {
        // tokens: {series} {S} {E} {ABS} {title}
        string MakeSafe(string s)
            => string.Join(" ", s.Split(Path.GetInvalidFileNameChars()));
        return pattern
            .Replace("{series}", MakeSafe(series))
            .Replace("{S}", ep.Season.ToString("00"))
            .Replace("{E}", ep.Episode.ToString("00"))
            .Replace("{ABS}", ep.Absolute.ToString("000"))
            .Replace("{title}", MakeSafe(ep.Title));
    }
}
```

---

## src/TvRenamer.App/TvRenamer.App.csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <UseWPF>true</UseWPF>
    <Nullable>enable</Nullable>
  </PropertyGroup>
  <ItemGroup>
    <ProjectReference Include="..\TvRenamer.Core\TvRenamer.Core.csproj" />
  </ItemGroup>
</Project>
```

## src/TvRenamer.App/App.xaml
```xml
<Application x:Class="TvRenamer.App.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
  <Application.Resources/>
</Application>
```

## src/TvRenamer.App/MainWindow.xaml
```xml
<Window x:Class="TvRenamer.App.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="TVRenamer" Height="680" Width="980"
        AllowDrop="True" Drop="Window_Drop">
  <Grid Margin="12">
    <Grid.ColumnDefinitions>
      <ColumnDefinition Width="*"/>
      <ColumnDefinition Width="Auto"/>
      <ColumnDefinition Width="*"/>
    </Grid.ColumnDefinitions>

    <GroupBox Header="Original Files" Margin="0,0,8,0">
      <ListBox x:Name="FilesList"/>
    </GroupBox>

    <StackPanel Grid.Column="1" VerticalAlignment="Center" Margin="8">
      <Button Content="Match" Click="Match_Click" Width="120" Margin="0,0,0,8"/>
      <Button Content="Rename" Click="Rename_Click" Width="120"/>
      <Separator Margin="0,12"/>
      <TextBlock Text="Provider" FontWeight="Bold" Margin="0,0,0,4"/>
      <ComboBox x:Name="ProviderCombo" Width="160">
        <ComboBoxItem Content="TheTVDB" IsSelected="True"/>
        <ComboBoxItem Content="TVMaze (fallback)"/>
      </ComboBox>
      <TextBlock Text="Pattern" FontWeight="Bold" Margin="0,12,0,4"/>
      <TextBox x:Name="PatternBox" Width="220" Text="{series} - S{S}E{E} - {title}"/>
      <TextBlock Text="Tip: use {ABS} for absolute numbering" Foreground="Gray"/>
    </StackPanel>

    <GroupBox Grid.Column="2" Header="New Names" Margin="8,0,0,0">
      <ListBox x:Name="PreviewList"/>
    </GroupBox>
  </Grid>
</Window>
```

## src/TvRenamer.App/MainWindow.xaml.cs
```csharp
using System.Collections.ObjectModel;
using System.Text.Json;
using TvRenamer.Core;

namespace TvRenamer.App;

public partial class MainWindow : Window
{
    private readonly ObservableCollection<string> _files = new();
    private readonly ObservableCollection<string> _previews = new();

    public MainWindow()
    {
        InitializeComponent();
        FilesList.ItemsSource = _files;
        PreviewList.ItemsSource = _previews;
    }

    private void Window_Drop(object sender, DragEventArgs e)
    {
        if (e.Data.GetDataPresent(DataFormats.FileDrop))
        {
            var paths = (string[])e.Data.GetData(DataFormats.FileDrop)!;
            foreach (var p in paths.SelectMany(p => Directory.Exists(p) ? Directory.EnumerateFiles(p, "*.*", SearchOption.AllDirectories) : new[] { p }))
            {
                if (new[] { ".mkv", ".mp4", ".avi", ".mov" }.Contains(Path.GetExtension(p).ToLowerInvariant()))
                    _files.Add(p);
            }
        }
    }

    private async void Match_Click(object sender, RoutedEventArgs e)
    {
        _previews.Clear();
        if (_files.Count == 0) return;

        // Guess the series name from the folder or file prefix (simple heuristic)
        var folder = Path.GetFileName(Path.GetDirectoryName(_files[0])!) ?? "";
        var guessName = ToTitle(folder.Replace('.', ' ').Replace('_', ' '));
        var pattern = PatternBox.Text;

        using var http = new HttpClient();

        IMetadataProvider provider = ProviderCombo.SelectedIndex == 0
            ? new TvdbProvider(http, LoadSecret("TVDB_APIKEY"), LoadSecretOrNull("TVDB_PIN"))
            : new TvMazeProvider(http);

        var series = await provider.SearchSeriesAsync(guessName, CancellationToken.None)
                    ?? await provider.SearchSeriesAsync(GuessSeriesFromFiles(), CancellationToken.None);
        if (series is null)
        {
            MessageBox.Show("Series not found. Try TVMaze fallback or tweak folder name.");
            return;
        }

        var eps = await provider.GetAllEpisodesAsync(series.SeriesId, CancellationToken.None);
        var map = eps
            .GroupBy(e => (e.Season, e.Episode))
            .ToDictionary(g => g.Key, g => g.First());
        var absMap = eps
            .GroupBy(e => e.Absolute)
            .ToDictionary(g => g.Key, g => g.First());

        foreach (var f in _files)
        {
            var (s, ept, abs) = FileParsing.ExtractNumbers(Path.GetFileName(f));
            EpisodeInfo? match = null;
            if (s.HasValue && ept.HasValue && map.TryGetValue((s.Value, ept.Value), out var see)) match = see;
            else if (abs.HasValue && absMap.TryGetValue(abs.Value, out var absee)) match = absee;

            if (match is null)
            {
                _previews.Add($"(no match) {Path.GetFileName(f)}");
                continue;
            }
            var newName = Renamer.BuildName(series.Name, match, pattern) + Path.GetExtension(f).ToLowerInvariant();
            _previews.Add(newName);
        }
    }

    private static string LoadSecret(string key)
        => Environment.GetEnvironmentVariable(key)
            ?? throw new InvalidOperationException($"Missing environment variable {key}");

    private static string? LoadSecretOrNull(string key)
        => Environment.GetEnvironmentVariable(key);

    private string GuessSeriesFromFiles()
    {
        // Fallback: common prefix of file names
        var names = _files.Select(f => Path.GetFileNameWithoutExtension(f)).ToList();
        if (names.Count == 0) return "";
        var prefix = names[0];
        foreach (var n in names.Skip(1))
        {
            int i=0; while (i < prefix.Length && i < n.Length && char.ToLowerInvariant(prefix[i]) == char.ToLowerInvariant(n[i])) i++;
            prefix = prefix[..i];
        }
        return ToTitle(prefix.Replace('.', ' ').Replace('_', ' ').Trim());
    }

    private static string ToTitle(string s)
        => System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(s.ToLowerInvariant());

    private async void Rename_Click(object sender, RoutedEventArgs e)
    {
        if (_previews.Count != _files.Count)
        {
            MessageBox.Show("Run Match first.");
            return;
        }
        for (int i = 0; i < _files.Count; i++)
        {
            var src = _files[i];
            var dst = Path.Combine(Path.GetDirectoryName(src)!, _previews[i]);
            if (dst.Contains("(no match)")) continue;
            try
            {
                File.Move(src, dst);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed: {src}\n{ex.Message}");
            }
        }
        MessageBox.Show("Done.");
    }
}
```

---

## src/TvRenamer.Installer/TvRenamer.Installer.wixproj
```xml
<Project ToolsVersion="4.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Compile Include="Product.wxs" />
  </ItemGroup>
  <PropertyGroup>
    <OutputName>TVRenamer</OutputName>
    <WixToolPath>$(WixToolPath)</WixToolPath>
    <WixTargetsPath>$(WixToolPath)\Wix.targets</WixTargetsPath>
  </PropertyGroup>
  <Import Project="$(WixTargetsPath)" />
</Project>
```

## src/TvRenamer.Installer/Product.wxs
```xml
<?xml version="1.0" encoding="UTF-8"?>
<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
  <Product Id="*" Name="TVRenamer" Language="1033" Version="1.0.0.0" Manufacturer="YourName" UpgradeCode="7B804E06-8E9D-49F6-82E7-CE62F63A5E4A">
    <Package InstallerVersion="510" Compressed="yes" InstallScope="perMachine" />

    <MediaTemplate />

    <Directory Id="TARGETDIR" Name="SourceDir">
      <Directory Id="ProgramFilesFolder">
        <Directory Id="INSTALLFOLDER" Name="TVRenamer" />
      </Directory>
      <Directory Id="ProgramMenuFolder">
        <Directory Id="ProgramMenuDir" Name="TVRenamer" />
      </Directory>
    </Directory>

    <DirectoryRef Id="INSTALLFOLDER">
      <Component Id="MainEXE" Guid="*">
        <File Id="AppExe" Source="..\TvRenamer.App\bin\Release\net8.0-windows\TvRenamer.App.exe" KeyPath="yes" />
      </Component>
    </DirectoryRef>

    <DirectoryRef Id="ProgramMenuDir">
      <Component Id="ProgramMenuShortcuts" Guid="*">
        <Shortcut Id="AppShortcut" Name="TVRenamer" Target="[INSTALLFOLDER]TvRenamer.App.exe" WorkingDirectory="INSTALLFOLDER" />
        <RemoveFolder Id="RemoveShortcutDir" On="uninstall" />
        <RegistryValue Root="HKCU" Key="Software\\TVRenamer" Name="installed" Type="integer" Value="1" KeyPath="yes" />
      </Component>
    </DirectoryRef>

    <Feature Id="MainFeature" Title="TVRenamer" Level="1">
      <ComponentRef Id="MainEXE" />
      <ComponentRef Id="ProgramMenuShortcuts" />
    </Feature>
  </Product>
</Wix>
```

---

## .github/workflows/build-msi.yml
```yaml
name: build-msi

on: [push, pull_request, workflow_dispatch]

jobs:
  build:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore & Build (Release)
        shell: pwsh
        run: |
          dotnet restore ./src/TvRenamer.App/TvRenamer.App.csproj
          dotnet build ./src/TvRenamer.App/TvRenamer.App.csproj -c Release --no-restore

      - name: Install WiX Toolset (v3.11)
        shell: pwsh
        run: choco install wixtoolset --yes --no-progress

      - name: Build MSI (WiX)
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force obj | Out-Null
          $wix = 'C:\Program Files (x86)\WiX Toolset v3.11\bin'
          & "$wix\candle.exe" "src\TvRenamer.Installer\Product.wxs" -o "obj\product.wixobj"
          & "$wix\light.exe"  "obj\product.wixobj" -o "TVRenamer.msi" -ext WixUIExtension

      - name: Upload MSI artifact
        uses: actions/upload-artifact@v4
        with:
          name: TVRenamer-Installer
          path: TVRenamer.msi
```

---

## README.md (key bits)
```md
# TVRenamer

Drag & drop TV files, auto‑match from TheTVDB (v4) or TVMaze, and rename.

## Quick start (dev)
1. Install .NET 8 SDK & WiX v3.11 (for local MSI builds).
2. Put your TVDB API key in an environment variable `TVDB_APIKEY`. If your key is user‑supported and you have a PIN, also set `TVDB_PIN`.
3. `dotnet build src/TvRenamer.App -c Release`
4. Run the app from `src/TvRenamer.App/bin/Release/net8.0-windows/TvRenamer.App.exe`.

## Rename pattern
Use tokens: `{series}`, `{S}`, `{E}`, `{ABS}`, `{title}`. Example:
```
{series} - 1x{E} - {title}
{series} - S{S}E{E} - {title}
{series} - {ABS} - {title}
```

## MSI via GitHub Actions
Push to `main` → workflow builds and uploads `TVRenamer.msi` under CI artifacts.
```
.github/workflows/build-msi.yml
```
```
```

## Notes
- TVDB token is acquired at runtime via `/v4/login` using your API key (and optional PIN).
- If TVDB rate-limits or is unavailable, switch the Provider dropdown to **TVMaze**.

